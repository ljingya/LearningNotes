#### 数据结构-数组篇

本文参考极客时间《数据结构与算法之美》。

数组的定义：一种线性数据表，一组连续的内存，存储一组相同的数据类型。

###### 线性表

数组，队列，栈，链表。

###### 非线形表

树，图，堆。

###### 连续的内存和相同的数据类型

由于这两点的限制，使数据在随机访问有天然的优势，但在删除和插入比较低效，

数组实现随机访问：

有一个int[]a=new int [10]的数组，分配了一块从1000-1039这样一块连续的内存地址，内存的首地址是1000，如果要随机访问某个元素时，元素的存储地址为：

```
a[i]_address=base_address(首地址)+i*data_type_size
```

![数组分配地址图](https://raw.githubusercontent.com/ljingya/LearningNotes/master/Image/%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80%E5%9B%BE.png) 

 <center>
     <u>图片地址分配图</u>  
</center>

data_type_size为数组中每个元素的大小，int类型的数据占据四个字节，byte数据占据一个字节。

对于“链表适合插入删除，其时间复杂度为O(1),数据适合查找，其时间复杂度为O(1)”这种说法有误解，例如排序好的数组，使用二分查找，其时间复杂度为O(logn),正确的表述是对于随机访问数组的时间复杂度为O(1)。

###### 插入和删除

在数组的末尾插入一个数据，时间复杂度为O(1),在数据的头部插入一个数据，时间复杂度为O(n),平均复杂度为O(n)。

当删除某个位置的数据时，为了保证内存的连续性，需要移动数据，当删除的数据在末尾时，时间复杂度为O(1),

当删除的数据在头部时，时间复杂度为O(n),平均时间复杂度为O(n)。为了减少搬移次数，可以先记录删除的位置，不进行真正的删除，当数组空间不足时一次性删除。

###### 数组越界

在C语言中并不会出现数组越界问题，因此C语言中只要不是内存受限，都是可用的内存，只是这块内存不在该数组上。

###### 容器与数组

java中提供了像ArrayList这样的容器，ArrayList封装了对数组的插入和删除操作，另外数组使用时需要定义本身的大小，当空间不足时需要重新申请一块更大的内存，而ArrayList则在底层已经封装好了，我们不需关心扩容的事情，会自动扩容，由于扩容是一件消耗内存的事情，如果事先已经知道数据的大小，可以制定ArrayList的大小。避免动态扩容。

1. ArrayList不支持基本数据类型，支持Integer，Boolean等类型，需要拆箱和自动装箱，也是耗时的。
2. 如果数据事先已经知道，操作比较简单可以考虑使用数组。
3. 当表示多维数组时更加直观。

###### 为什么数组编号从0开始

上面提到的数组内存分配的例子，a[0]是偏移为0的地址，也就是首地址，偏移为k的地址如下公式

```
a[k]_address=base_address(首地址)+k*data_type_size
```

若数组的下标从1开始计数时，偏移为k的地址为

```
a[k]_address=base_address(首地址)+(k-1)*data_type_size
```

从公式上看多了一次减法操作。基于效率因此数组的下标从0开始计数。